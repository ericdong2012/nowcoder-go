1. 可以判断是否是2的幂
n : 8    01000
-n: -8   11000
n & (-n) == n

2. 去掉最后的数字
n & (n -1 )   0 / 1     10 & 01 = 00

3. 颠倒
# 写法1
# res 左移一位 +  末尾的数字 0 / 1
# a = 0b101
#     00001
# res = (res << 1) + (n & 1)
# n = n >> 1

# 写法2
# https://leetcode-cn.com/problems/reverse-bits/solution/huo-qu-zui-di-wei-you-yi-yi-wei-fan-hui-zhi-zuo-yi/
last = n & 1  # 获取最后一个 bit
res <<= 1  # 给最后一位留出空间
res |= last  # 把最后一位给补上去
n >>= 1  # 右移一位


4. 唯一数
a ^= i

# a = 4
# a = 4 ^ 1
# a = 4 ^ 1 ^ 2
# a = 4 ^ 1 ^ 2 ^ 1  = 4 ^ 2 ^ 0 = 4 ^ 2
# a = 4 ^ 2 ^ 2 = 4

一个数和 0 做 XOR 运算等于本身：a^0 = a
一个数和其本身做 XOR 运算等于 0：a^a = 0
XOR 运算满***换律和结合律：a^b^a = (a^a)^b = 0^b = b


5. 判断奇数偶数
i & 1

x / 2  ==  x >> 1
x % 2   ==  x & 1


奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
  举例：
     0 = 0       1 = 1
     2 = 10      3 = 11
     4 = 100     5 = 101


偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。
  举例：
      2 = 10       4 = 100       8 = 1000
      3 = 11       6 = 110       12 = 1100

数位数
if i & 1:
    dp[i] = dp[i - 1] + 1
# 偶数
else:
    # dp[i]  =  dp[i / 2 ]  或者 dp[i >> 2] 都不行
    # 写法1
    # dp[i] = dp[i // 2]
    # 写法2：关注的是偶数为是否是2的幂， 比如 8 和 10 两种情况
    dp[i] = 1 if i & -i == i else 2






